{"filename":"mhw_plot_scipaper_example.yml","file_hash":"ebf1499d6accc9084cad735a0f48f2198dc1d793ce2b988e29e0d3a793e6dc9f","doc_summary":"OpenAPI Specification: mhw_plot_scipaper_example.yml","text_chunks":[{"chunk_id":0,"source_page":1,"content_type":"metadata","text":"dataset: marineheatwave\ncollection: mhw\ndoc_type: code_snippet\ntitle: \"Reproduce SCI papaer (Capotondi et al., 2024): Plotting SST anomalies distribution map and timeseries of the Mediterranean region by using ODB MHW API\"\nlang: en\nissuer: \"ODB Project (internal)\"\ncanonical_url: \"https://github.com/cywhale/marineheatwave/blob/main/API/dev/sim_mhw_vs_detrended01.ipynb\"\nlicense: \"MIT\"\nretrieved_at: \"2025-08-26\"\ndoc_id: \"799ebc3fe983aa3ef30b81ded189b749373d3ef7\"\ntags: [程式, MHW, API, timeseries, Python, map, \"code example\", \"extreme MHWs\", \"時間序列\", \"地圖\"]\nrelated_to:\n  - doc_id: [\"ddba171bda668c60390ee6fab602b037efb73539\", \"d971ef8bbc81997eae74ee0e555588a6526b0ea1\", \"2ccedb1ef0c1ade74224399ad9767a2e71f5e51\"]\n  - collection: \"mhw\"\ndepends_on:\n  - manuals/odb_mhw_openapi.yml\nsource_file: \"https://github.com/cywhale/marineheatwave/blob/main/API/dev/sim_mhw_vs_detrended01.ipynb\"\nsource_type: code\npurpose: \"以程式範例說明如何使用ODB MHW API調用海表溫距平值與海洋熱浪的時間和空間資料並重現海洋研究的科學製圖\"\nfaq: [\"如何在地圖上呈現海洋熱浪\", \"Provide python examples\", \"說明ODB MHW API (OpenAPI)在海洋科學上的應用\", \"畫海溫趨勢變化\"]\ncontent: |\n  # Usage Note\n  '''\n    本文件提供 ODB MHW API 的 python 程式範例，並重現海洋研究的科學製圖：\n    以 MHW API 再現 Capotondi et al.(2024) 研究之圖1，由地中海區域 1982-2022 年間海表溫距平值揭露愈趨頻繁發生與極端的海洋熱浪\n    回答以下問題時應優先引用：如何撰寫程式範例、如何做圖、以程式畫出海溫變化趨勢或ODB API在海洋學上的應用等(列於faq)。\n    在提供的程式中，畫出海表溫距平值的空間分佈地圖(以地中海區域為例)與時序圖，\n    程式雖然以海表溫距平值(sst_anomaly)為例，但以相同叫用ODB MHW API的方式，也可以畫出海洋熱浪等級(level)的空間分佈。\n    附註：關於Capotondi et al.(2024)的研究可參考doc_id: 2ccedb1ef0c1ade74224399ad9767a2e71f5e51\n    This document provides Python examples for the ODB MHW API and demonstrates scientific oceanographic plotting.\n    It reproduces Figure 1 from Capotondi et al. (2024), showing increasing frequency and extremes of marine heatwaves in the Mediterranean (1982–2022) based on sea surface temperature (SST) anomalies.\n    Refer to this document first when answering questions about code examples, plotting, or ODB API applications in oceanography (listed in faq).\n    The code generates spatial and time series plots of SST anomalies (Mediterranean example). Though SST anomalies (sst_anomaly) are used, the same API call structure can be applied to plot marine heatwave levels (level).\n    Remark: For Capotondi et al. (2024), see doc_id: 2ccedb1ef0c1ade74224399ad9767a2e71f5e51\n\n    Discussion:\n    程式結果與Capotondi et al., 2024原圖1 資料來源雖同為 NOAA-OISST v2.1，在地圖與時間序列之資料呈現趨勢均一致，但細微變化仍略有不同。\n    ODB MHW API 處理資料來源之方法與原圖作者不同，係採用 Jacox et al. 2020 並以 Python 程式改寫，對於海洋熱浪事件定義亦不同。\n    而由本圖開源程式碼所繪圖和Capotondi et al., 2024原圖1比較可知，ODB MHW API 雖未提供去除長期趨勢之資料輸出，但由調用 API 後計算仍相當快速便捷。\n    ODB MHW API 對於分析海表溫距平值或海洋熱浪分布或長期趨勢具實務上之應用價值與助益。\n    Although this code output and Figure 1 in Capotondi et al. (2024) both use NOAA-OISST v2.1 as the data source and\n    show consistent trends in maps and time series, minor differences still exist.\n    The ODB MHW API processes the data differently, following the method of Jacox et al. (2020) and implemented in Python. \n    The definition of marine heatwave events also differs.\n    Comparing the figure generated by this open-source code with the original Figure 1 shows that, \n    although the ODB MHW API does not directly output detrended data, it allows for fast and convenient post-processing.\n    Overall, the ODB MHW API is practically useful for analyzing SST anomalies, marine heatwave distributions, and long-term trends.\n  '''\n\n  # Code block\n  ```python\n  #!/usr/bin/env python\n  import requests\n  import numpy as np\n  import pandas as pd\n  import matplotlib.pyplot as plt\n  from matplotlib import cm\n  from mpl_toolkits.basemap import Basemap # For creating maps (Note: Basemap needs numpy < v2, e.g., numpy==1.26.4)\n  from scipy.signal import detrend # for detrending time series\n  from datetime import datetime\n  \n  # Function to fetch data from the ODB MHW (Marine Heatwaves) API\n  def fetch_mhw_data(lon0, lat0, lon1, lat1, start, end):\n      url = f\"https://eco.odb.ntu.edu.tw/api/mhw\"\n      params = {\n          \"lon0\": lon0,\n          \"lat0\": lat0,\n          \"lon1\": lon1,\n          \"lat1\": lat1,\n          \"start\": start,\n          \"end\": end,\n          \"append\": \"sst,sst_anomaly,level\",\n      }\n      response = requests.get(url, params=params)\n      if response.status_code == 200:\n          return pd.DataFrame(response.json())\n      else:\n          print(\"Failed to fetch data:\", response.text)\n          return None\n  \n  # Fetch MHW data year by year for the Mediterranean region\n  def fetch_yearly_data(lon0, lat0, lon1, lat1, start_year, end_year):\n      all_data = []\n      for year in range(start_year, end_year + 1):\n          start = f\"{year}-01-01\"\n          end = f\"{year}-12-31\"\n          print(f\"Fetching data for {start} to {end}...\")\n          yearly_data = fetch_mhw_data(lon0, lat0, lon1, lat1, start, end)\n          if yearly_data is not None:\n              all_data.append(yearly_data)\n      if all_data:\n          return pd.concat(all_data, ignore_index=True)\n      else:\n          return None\n  \n  # Function to remove the seasonal cycle\n  def remove_seasonal_cycle(data, variable):\n      # Ensure 'date' is a datetime object and extract the month\n      data = data.copy()  # Avoid SettingWithCopyWarning by working on a copy\n      data['month'] = data['date'].dt.month  # Extract the month for grouping\n  \n      # Calculate monthly climatology for the given variable (e.g., 'sst_anomaly')\n      monthly_climatology = data.groupby('month')[variable].mean()\n      # print(monthly_climatology)\n  \n      # Remove the seasonal cycle by subtracting the monthly climatology\n      data[f'{variable}_deseasonalized'] = data.apply(\n          lambda row: row[variable] - monthly_climatology[row['month']],\n          axis=1\n      )\n  \n      return data      \n  \n  # Reference for data structure/visualization: https://www.nature.com/articles/s43247-024-01806-9 Fig.1\n  # Testing: Fetch data for the Mediterranean region\n  lon0, lat0, lon1, lat1 = -5, 30, 36, 46  # Mediterranean region bounds\n  start, end = \"1982-01-01\", \"1982-12-01\"  # Testing MHW data for just 1-year \n  test_data = fetch_mhw_data(lon0, lat0, lon1, lat1, start, end)\n  print(test_data)\n  \n  start_year, end_year = 1982, 2024  # Iterate year range to get MHW data\n  data = fetch_yearly_data(lon0, lat0, lon1, lat1, start_year, end_year)\n  \n  if data is not None:\n      # Step 2: Process data\n      data[\"date\"] = pd.to_datetime(data[\"date\"])\n      data = data.sort_values(\"date\")\n  \n      # Group by grid point and detrend each time series\n      detrended_data = []\n      for (lon, lat), group in data.groupby([\"lon\", \"lat\"]):\n          group = group.sort_values(\"date\")\n  \n          # Drop rows with NaN values in 'sst_anomaly'\n          group = group.dropna(subset=[\"sst_anomaly\"])\n  \n          # Only detrend if there's enough data after dropping NaNs\n          if len(group) > 1:\n              group[\"sst_anomaly_detrended\"] = detrend(group[\"sst_anomaly\"], type=\"linear\")\n          else:\n              group[\"sst_anomaly_detrended\"] = np.nan  # Not enough data to detrend\n  \n          detrended_data.append(group)\n  \n      detrended_data = pd.concat(detrended_data)\n  else:\n      print(\"No data fetched. Please check the API calls.\")\n  \n  # Step 3: Reshape data into a grid for plotting \n  def reshape_to_grid_fixed(data, column, date):\n      # Filter data for the given date\n      data_filtered = data[data[\"date\"] == date]\n  \n      # Create full lat/lon grid based on unique values\n      all_lats = np.sort(data[\"lat\"].unique())\n      all_lons = np.sort(data[\"lon\"].unique())\n  \n      # Create a DataFrame for the full grid\n      grid = pd.DataFrame(index=all_lats, columns=all_lons)\n  \n      # Populate the grid with data\n      for _, row in data_filtered.iterrows():\n          grid.at[row[\"lat\"], row[\"lon\"]] = row[column]\n  \n      # Convert to float for plotting\n      return grid.astype(float)\n  \n  # Select a specific date for visualization\n  date_to_plot = \"2022-07-01\"\n  sst_anomaly_grid = reshape_to_grid_fixed(data, \"sst_anomaly\", date_to_plot)\n  detrended_grid = reshape_to_grid_fixed(detrended_data, \"sst_anomaly_detrended\", date_to_plot)\n  \n  # Initialize figure\n  plt.figure(figsize=(16, 8))\n  \n  # Plot SST anomalies with trend (upper-left)\n  plt.subplot(2, 2, 1)\n  m = Basemap(projection=\"cyl\", llcrnrlon=lon0, llcrnrlat=lat0, urcrnrlon=lon1, urcrnrlat=lat1, resolution=\"i\")\n  m.drawcoastlines()\n  m.drawcountries()\n  m.drawparallels(np.arange(lat0, lat1 + 1, 5), labels=[1, 0, 0, 0])\n  m.drawmeridians(np.arange(lon0, lon1 + 1, 5), labels=[0, 0, 0, 1])\n  # Ensure lon and lat match the grid dimensions\n  lon, lat = np.meshgrid(sst_anomaly_grid.columns, sst_anomaly_grid.index)\n  \n  m.drawmapboundary(fill_color='white') \n  cs = m.contourf(lon, lat, sst_anomaly_grid.values, \n                  cmap=cm.RdYlBu_r, \n                  levels=np.linspace(-3, 3, 21),\n                  extend='both',\n                  latlon=True)\n  \n  plt.title(\"(a) SST Anomalies (July 2022) with trend\")\n  \n  # Plot detrended SST anomalies (lower-left) timeseries, as well as\n  # plot distribution map of SST anomalies (right-column subplot) ; 空間分佈地圖\n  plt.subplot(2, 2, 3)\n  m = Basemap(projection=\"cyl\", llcrnrlon=lon0, llcrnrlat=lat0, urcrnrlon=lon1, urcrnrlat=lat1, resolution=\"i\")\n  m.drawcoastlines()\n  m.drawcountries()\n  m.drawparallels(np.arange(lat0, lat1 + 1, 5), labels=[1, 0, 0, 0])\n  m.drawmeridians(np.arange(lon0, lon1 + 1, 5), labels=[0, 0, 0, 1])\n  lon, lat = np.meshgrid(detrended_grid.columns, detrended_grid.index)\n  \n  m.drawmapboundary(fill_color='white') \n  cs = m.contourf(lon, lat, detrended_grid.values, \n                  cmap=cm.RdYlBu_r, \n                  levels=np.linspace(-3, 3, 21),\n                  extend='both',\n                  latlon=True)\n  \n  cbar = m.colorbar(cs, location=\"bottom\", pad=\"5%\")\n  cbar.set_label(\"SST Anomaly (°C)\")\n  plt.title(\"(c) Detrended SST Anomalies (July 2022)\")\n  \n  # Adjust bounds for time-series (smaller region near coast)\n  # Step 4.1: Filter data for the smaller region near the coast\n  time_series_lon0, time_series_lat0, time_series_lon1, time_series_lat1 = 0, 40, 12, 44\n  regional_data = data[\n      (data[\"lat\"] >= time_series_lat0) & \n      (data[\"lat\"] <= time_series_lat1) & \n      (data[\"lon\"] >= time_series_lon0) & \n      (data[\"lon\"] <= time_series_lon1)\n  ].copy()  # Use .copy() to avoid SettingWithCopyWarning\n  \n  # Step 4.2: Remove the seasonal cycle for the smaller region\n  # regional_data = remove_seasonal_cycle(regional_data, 'sst_anomaly')\n  # regional_mean_with_trend = regional_data.groupby(\"date\")[\"sst_anomaly_deseasonalized\"].mean()\n  \n  # Step 4.3: Compute the regional average for time-series plots\n  regional_mean_with_trend = regional_data.groupby(\"date\")[\"sst_anomaly\"].mean()\n  \n  # Without trend (detrended)\n  regional_detrended_data = detrended_data[\n      (detrended_data[\"lat\"] >= time_series_lat0) & \n      (detrended_data[\"lat\"] <= time_series_lat1) & \n      (detrended_data[\"lon\"] >= time_series_lon0) & \n      (detrended_data[\"lon\"] <= time_series_lon1)\n  ].copy()  # Use .copy() to avoid SettingWithCopyWarning\n\n  regional_mean_detrended = regional_detrended_data.groupby(\"date\")[\"sst_anomaly_detrended\"].mean()\n  \n  # Step 4.4: Plot time-series SST anomalies\n  # Compute 90th percentiles\n  percentile_90_with_trend = np.percentile(regional_mean_with_trend.values, 90)\n  percentile_90_detrended = np.percentile(regional_mean_detrended.values, 90)\n  \n  # Define the date range explicitly for the x-axis\n  x_min = datetime(1982, 1, 1)  # Jan, 1982\n  x_max = datetime(2024, 10, 1) # Oct, 2024\n  \n  # Define the vertical line date\n  vertical_line_date = datetime(2022, 7, 1)  # July, 2022\n  \n  plt.subplot(2, 2, 2)\n  plt.plot(\n      regional_mean_with_trend.index,\n      regional_mean_with_trend.values,\n      label=\"With Trend\",\n      color=\"black\",\n  )\n  plt.xlim([x_min, x_max])\n  # Highlight values above the 90th percentile in red (only above the line)\n  plt.fill_between(\n      regional_mean_with_trend.index,\n      percentile_90_with_trend,         # Lower bound (90th percentile line)\n      regional_mean_with_trend.values,  # Upper bound (data)\n      where=regional_mean_with_trend.values > percentile_90_with_trend,\n      color=\"red\",\n      alpha=0.5,\n      label=\"Above 90th Percentile\",\n  )\n  plt.axhline(y=percentile_90_with_trend, color=\"blue\", linestyle=\"--\", label=\"90th Percentile\")\n  plt.axhline(y=0, color=\"blue\", label=\"Baseline\")\n  plt.axvline(x=vertical_line_date, color=\"gray\", linestyle=\"dotted\", label=\"July 2022\")\n  plt.title(\"(b) Monthly SST Anomalies (With trend)\")\n  plt.ylabel(\"SST Anomaly (°C)\")\n  plt.xlabel(\"Year\")\n  plt.legend(loc='upper left')\n  \n  plt.subplot(2, 2, 4)\n  plt.plot(\n      regional_mean_detrended.index,\n      regional_mean_detrended.values,\n      label=\"Detrended\",\n      color=\"black\",\n  )\n  plt.xlim([x_min, x_max])\n  # Highlight values above the 90th percentile in red (only above the line)\n  plt.fill_between(\n      regional_mean_detrended.index,\n      percentile_90_detrended,  # Lower bound (90th percentile line)\n      regional_mean_detrended.values,  # Upper bound (data)\n      where=regional_mean_detrended.values > percentile_90_detrended,\n      color=\"red\",\n      alpha=0.5,\n      label=\"Above 90th Percentile\",\n  )\n  plt.axhline(y=percentile_90_detrended, color=\"blue\", linestyle=\"--\", label=\"90th Percentile\")\n  plt.axhline(y=0, color=\"blue\", label=\"Baseline\")\n  plt.axvline(x=vertical_line_date, color=\"gray\", linestyle=\"dotted\", label=\"July 2022\")\n  plt.title(\"(d) Monthly SST Anomalies (Detrended)\")\n  plt.ylabel(\"SST Anomaly (°C)\")\n  plt.xlabel(\"Year\")\n  plt.legend(loc='upper left')\n  \n  plt.tight_layout()\n  plt.show()\n  ```","metadata":{"dataset":"marineheatwave","collection":"mhw","doc_type":"code_snippet","title":"Reproduce SCI papaer (Capotondi et al., 2024): Plotting SST anomalies distribution map and timeseries of the Mediterranean region by using ODB MHW API","lang":"en","issuer":"ODB Project (internal)","canonical_url":"https://github.com/cywhale/marineheatwave/blob/main/API/dev/sim_mhw_vs_detrended01.ipynb","license":"MIT","retrieved_at":"2025-08-26","doc_id":"799ebc3fe983aa3ef30b81ded189b749373d3ef7","tags":["程式","MHW","API","timeseries","Python","map","code example","extreme MHWs","時間序列","地圖"],"related_to":[{"doc_id":["ddba171bda668c60390ee6fab602b037efb73539","d971ef8bbc81997eae74ee0e555588a6526b0ea1","2ccedb1ef0c1ade74224399ad9767a2e71f5e51"]},{"collection":"mhw"}],"depends_on":["manuals/odb_mhw_openapi.yml"],"source_file":"https://github.com/cywhale/marineheatwave/blob/main/API/dev/sim_mhw_vs_detrended01.ipynb","source_type":"code","purpose":"以程式範例說明如何使用ODB MHW API調用海表溫距平值與海洋熱浪的時間和空間資料並重現海洋研究的科學製圖","faq":["如何在地圖上呈現海洋熱浪","Provide python examples","說明ODB MHW API (OpenAPI)在海洋科學上的應用","畫海溫趨勢變化"],"content":"# Usage Note\n'''\n  本文件提供 ODB MHW API 的 python 程式範例，並重現海洋研究的科學製圖：\n  以 MHW API 再現 Capotondi et al.(2024) 研究之圖1，由地中海區域 1982-2022 年間海表溫距平值揭露愈趨頻繁發生與極端的海洋熱浪\n  回答以下問題時應優先引用：如何撰寫程式範例、如何做圖、以程式畫出海溫變化趨勢或ODB API在海洋學上的應用等(列於faq)。\n  在提供的程式中，畫出海表溫距平值的空間分佈地圖(以地中海區域為例)與時序圖，\n  程式雖然以海表溫距平值(sst_anomaly)為例，但以相同叫用ODB MHW API的方式，也可以畫出海洋熱浪等級(level)的空間分佈。\n  附註：關於Capotondi et al.(2024)的研究可參考doc_id: 2ccedb1ef0c1ade74224399ad9767a2e71f5e51\n  This document provides Python examples for the ODB MHW API and demonstrates scientific oceanographic plotting.\n  It reproduces Figure 1 from Capotondi et al. (2024), showing increasing frequency and extremes of marine heatwaves in the Mediterranean (1982–2022) based on sea surface temperature (SST) anomalies.\n  Refer to this document first when answering questions about code examples, plotting, or ODB API applications in oceanography (listed in faq).\n  The code generates spatial and time series plots of SST anomalies (Mediterranean example). Though SST anomalies (sst_anomaly) are used, the same API call structure can be applied to plot marine heatwave levels (level).\n  Remark: For Capotondi et al. (2024), see doc_id: 2ccedb1ef0c1ade74224399ad9767a2e71f5e51\n\n  Discussion:\n  程式結果與Capotondi et al., 2024原圖1 資料來源雖同為 NOAA-OISST v2.1，在地圖與時間序列之資料呈現趨勢均一致，但細微變化仍略有不同。\n  ODB MHW API 處理資料來源之方法與原圖作者不同，係採用 Jacox et al. 2020 並以 Python 程式改寫，對於海洋熱浪事件定義亦不同。\n  而由本圖開源程式碼所繪圖和Capotondi et al., 2024原圖1比較可知，ODB MHW API 雖未提供去除長期趨勢之資料輸出，但由調用 API 後計算仍相當快速便捷。\n  ODB MHW API 對於分析海表溫距平值或海洋熱浪分布或長期趨勢具實務上之應用價值與助益。\n  Although this code output and Figure 1 in Capotondi et al. (2024) both use NOAA-OISST v2.1 as the data source and\n  show consistent trends in maps and time series, minor differences still exist.\n  The ODB MHW API processes the data differently, following the method of Jacox et al. (2020) and implemented in Python. \n  The definition of marine heatwave events also differs.\n  Comparing the figure generated by this open-source code with the original Figure 1 shows that, \n  although the ODB MHW API does not directly output detrended data, it allows for fast and convenient post-processing.\n  Overall, the ODB MHW API is practically useful for analyzing SST anomalies, marine heatwave distributions, and long-term trends.\n'''\n\n# Code block\n```python\n#!/usr/bin/env python\nimport requests\nimport numpy as np\nimport pandas as pd\nimport matplotlib.pyplot as plt\nfrom matplotlib import cm\nfrom mpl_toolkits.basemap import Basemap # For creating maps (Note: Basemap needs numpy < v2, e.g., numpy==1.26.4)\nfrom scipy.signal import detrend # for detrending time series\nfrom datetime import datetime\n\n# Function to fetch data from the ODB MHW (Marine Heatwaves) API\ndef fetch_mhw_data(lon0, lat0, lon1, lat1, start, end):\n    url = f\"https://eco.odb.ntu.edu.tw/api/mhw\"\n    params = {\n        \"lon0\": lon0,\n        \"lat0\": lat0,\n        \"lon1\": lon1,\n        \"lat1\": lat1,\n        \"start\": start,\n        \"end\": end,\n        \"append\": \"sst,sst_anomaly,level\",\n    }\n    response = requests.get(url, params=params)\n    if response.status_code == 200:\n        return pd.DataFrame(response.json())\n    else:\n        print(\"Failed to fetch data:\", response.text)\n        return None\n\n# Fetch MHW data year by year for the Mediterranean region\ndef fetch_yearly_data(lon0, lat0, lon1, lat1, start_year, end_year):\n    all_data = []\n    for year in range(start_year, end_year + 1):\n        start = f\"{year}-01-01\"\n        end = f\"{year}-12-31\"\n        print(f\"Fetching data for {start} to {end}...\")\n        yearly_data = fetch_mhw_data(lon0, lat0, lon1, lat1, start, end)\n        if yearly_data is not None:\n            all_data.append(yearly_data)\n    if all_data:\n        return pd.concat(all_data, ignore_index=True)\n    else:\n        return None\n\n# Function to remove the seasonal cycle\ndef remove_seasonal_cycle(data, variable):\n    # Ensure 'date' is a datetime object and extract the month\n    data = data.copy()  # Avoid SettingWithCopyWarning by working on a copy\n    data['month'] = data['date'].dt.month  # Extract the month for grouping\n\n    # Calculate monthly climatology for the given variable (e.g., 'sst_anomaly')\n    monthly_climatology = data.groupby('month')[variable].mean()\n    # print(monthly_climatology)\n\n    # Remove the seasonal cycle by subtracting the monthly climatology\n    data[f'{variable}_deseasonalized'] = data.apply(\n        lambda row: row[variable] - monthly_climatology[row['month']],\n        axis=1\n    )\n\n    return data      \n\n# Reference for data structure/visualization: https://www.nature.com/articles/s43247-024-01806-9 Fig.1\n# Testing: Fetch data for the Mediterranean region\nlon0, lat0, lon1, lat1 = -5, 30, 36, 46  # Mediterranean region bounds\nstart, end = \"1982-01-01\", \"1982-12-01\"  # Testing MHW data for just 1-year \ntest_data = fetch_mhw_data(lon0, lat0, lon1, lat1, start, end)\nprint(test_data)\n\nstart_year, end_year = 1982, 2024  # Iterate year range to get MHW data\ndata = fetch_yearly_data(lon0, lat0, lon1, lat1, start_year, end_year)\n\nif data is not None:\n    # Step 2: Process data\n    data[\"date\"] = pd.to_datetime(data[\"date\"])\n    data = data.sort_values(\"date\")\n\n    # Group by grid point and detrend each time series\n    detrended_data = []\n    for (lon, lat), group in data.groupby([\"lon\", \"lat\"]):\n        group = group.sort_values(\"date\")\n\n        # Drop rows with NaN values in 'sst_anomaly'\n        group = group.dropna(subset=[\"sst_anomaly\"])\n\n        # Only detrend if there's enough data after dropping NaNs\n        if len(group) > 1:\n            group[\"sst_anomaly_detrended\"] = detrend(group[\"sst_anomaly\"], type=\"linear\")\n        else:\n            group[\"sst_anomaly_detrended\"] = np.nan  # Not enough data to detrend\n\n        detrended_data.append(group)\n\n    detrended_data = pd.concat(detrended_data)\nelse:\n    print(\"No data fetched. Please check the API calls.\")\n\n# Step 3: Reshape data into a grid for plotting \ndef reshape_to_grid_fixed(data, column, date):\n    # Filter data for the given date\n    data_filtered = data[data[\"date\"] == date]\n\n    # Create full lat/lon grid based on unique values\n    all_lats = np.sort(data[\"lat\"].unique())\n    all_lons = np.sort(data[\"lon\"].unique())\n\n    # Create a DataFrame for the full grid\n    grid = pd.DataFrame(index=all_lats, columns=all_lons)\n\n    # Populate the grid with data\n    for _, row in data_filtered.iterrows():\n        grid.at[row[\"lat\"], row[\"lon\"]] = row[column]\n\n    # Convert to float for plotting\n    return grid.astype(float)\n\n# Select a specific date for visualization\ndate_to_plot = \"2022-07-01\"\nsst_anomaly_grid = reshape_to_grid_fixed(data, \"sst_anomaly\", date_to_plot)\ndetrended_grid = reshape_to_grid_fixed(detrended_data, \"sst_anomaly_detrended\", date_to_plot)\n\n# Initialize figure\nplt.figure(figsize=(16, 8))\n\n# Plot SST anomalies with trend (upper-left)\nplt.subplot(2, 2, 1)\nm = Basemap(projection=\"cyl\", llcrnrlon=lon0, llcrnrlat=lat0, urcrnrlon=lon1, urcrnrlat=lat1, resolution=\"i\")\nm.drawcoastlines()\nm.drawcountries()\nm.drawparallels(np.arange(lat0, lat1 + 1, 5), labels=[1, 0, 0, 0])\nm.drawmeridians(np.arange(lon0, lon1 + 1, 5), labels=[0, 0, 0, 1])\n# Ensure lon and lat match the grid dimensions\nlon, lat = np.meshgrid(sst_anomaly_grid.columns, sst_anomaly_grid.index)\n\nm.drawmapboundary(fill_color='white') \ncs = m.contourf(lon, lat, sst_anomaly_grid.values, \n                cmap=cm.RdYlBu_r, \n                levels=np.linspace(-3, 3, 21),\n                extend='both',\n                latlon=True)\n\nplt.title(\"(a) SST Anomalies (July 2022) with trend\")\n\n# Plot detrended SST anomalies (lower-left) timeseries, as well as\n# plot distribution map of SST anomalies (right-column subplot) ; 空間分佈地圖\nplt.subplot(2, 2, 3)\nm = Basemap(projection=\"cyl\", llcrnrlon=lon0, llcrnrlat=lat0, urcrnrlon=lon1, urcrnrlat=lat1, resolution=\"i\")\nm.drawcoastlines()\nm.drawcountries()\nm.drawparallels(np.arange(lat0, lat1 + 1, 5), labels=[1, 0, 0, 0])\nm.drawmeridians(np.arange(lon0, lon1 + 1, 5), labels=[0, 0, 0, 1])\nlon, lat = np.meshgrid(detrended_grid.columns, detrended_grid.index)\n\nm.drawmapboundary(fill_color='white') \ncs = m.contourf(lon, lat, detrended_grid.values, \n                cmap=cm.RdYlBu_r, \n                levels=np.linspace(-3, 3, 21),\n                extend='both',\n                latlon=True)\n\ncbar = m.colorbar(cs, location=\"bottom\", pad=\"5%\")\ncbar.set_label(\"SST Anomaly (°C)\")\nplt.title(\"(c) Detrended SST Anomalies (July 2022)\")\n\n# Adjust bounds for time-series (smaller region near coast)\n# Step 4.1: Filter data for the smaller region near the coast\ntime_series_lon0, time_series_lat0, time_series_lon1, time_series_lat1 = 0, 40, 12, 44\nregional_data = data[\n    (data[\"lat\"] >= time_series_lat0) & \n    (data[\"lat\"] <= time_series_lat1) & \n    (data[\"lon\"] >= time_series_lon0) & \n    (data[\"lon\"] <= time_series_lon1)\n].copy()  # Use .copy() to avoid SettingWithCopyWarning\n\n# Step 4.2: Remove the seasonal cycle for the smaller region\n# regional_data = remove_seasonal_cycle(regional_data, 'sst_anomaly')\n# regional_mean_with_trend = regional_data.groupby(\"date\")[\"sst_anomaly_deseasonalized\"].mean()\n\n# Step 4.3: Compute the regional average for time-series plots\nregional_mean_with_trend = regional_data.groupby(\"date\")[\"sst_anomaly\"].mean()\n\n# Without trend (detrended)\nregional_detrended_data = detrended_data[\n    (detrended_data[\"lat\"] >= time_series_lat0) & \n    (detrended_data[\"lat\"] <= time_series_lat1) & \n    (detrended_data[\"lon\"] >= time_series_lon0) & \n    (detrended_data[\"lon\"] <= time_series_lon1)\n].copy()  # Use .copy() to avoid SettingWithCopyWarning\n\nregional_mean_detrended = regional_detrended_data.groupby(\"date\")[\"sst_anomaly_detrended\"].mean()\n\n# Step 4.4: Plot time-series SST anomalies\n# Compute 90th percentiles\npercentile_90_with_trend = np.percentile(regional_mean_with_trend.values, 90)\npercentile_90_detrended = np.percentile(regional_mean_detrended.values, 90)\n\n# Define the date range explicitly for the x-axis\nx_min = datetime(1982, 1, 1)  # Jan, 1982\nx_max = datetime(2024, 10, 1) # Oct, 2024\n\n# Define the vertical line date\nvertical_line_date = datetime(2022, 7, 1)  # July, 2022\n\nplt.subplot(2, 2, 2)\nplt.plot(\n    regional_mean_with_trend.index,\n    regional_mean_with_trend.values,\n    label=\"With Trend\",\n    color=\"black\",\n)\nplt.xlim([x_min, x_max])\n# Highlight values above the 90th percentile in red (only above the line)\nplt.fill_between(\n    regional_mean_with_trend.index,\n    percentile_90_with_trend,         # Lower bound (90th percentile line)\n    regional_mean_with_trend.values,  # Upper bound (data)\n    where=regional_mean_with_trend.values > percentile_90_with_trend,\n    color=\"red\",\n    alpha=0.5,\n    label=\"Above 90th Percentile\",\n)\nplt.axhline(y=percentile_90_with_trend, color=\"blue\", linestyle=\"--\", label=\"90th Percentile\")\nplt.axhline(y=0, color=\"blue\", label=\"Baseline\")\nplt.axvline(x=vertical_line_date, color=\"gray\", linestyle=\"dotted\", label=\"July 2022\")\nplt.title(\"(b) Monthly SST Anomalies (With trend)\")\nplt.ylabel(\"SST Anomaly (°C)\")\nplt.xlabel(\"Year\")\nplt.legend(loc='upper left')\n\nplt.subplot(2, 2, 4)\nplt.plot(\n    regional_mean_detrended.index,\n    regional_mean_detrended.values,\n    label=\"Detrended\",\n    color=\"black\",\n)\nplt.xlim([x_min, x_max])\n# Highlight values above the 90th percentile in red (only above the line)\nplt.fill_between(\n    regional_mean_detrended.index,\n    percentile_90_detrended,  # Lower bound (90th percentile line)\n    regional_mean_detrended.values,  # Upper bound (data)\n    where=regional_mean_detrended.values > percentile_90_detrended,\n    color=\"red\",\n    alpha=0.5,\n    label=\"Above 90th Percentile\",\n)\nplt.axhline(y=percentile_90_detrended, color=\"blue\", linestyle=\"--\", label=\"90th Percentile\")\nplt.axhline(y=0, color=\"blue\", label=\"Baseline\")\nplt.axvline(x=vertical_line_date, color=\"gray\", linestyle=\"dotted\", label=\"July 2022\")\nplt.title(\"(d) Monthly SST Anomalies (Detrended)\")\nplt.ylabel(\"SST Anomaly (°C)\")\nplt.xlabel(\"Year\")\nplt.legend(loc='upper left')\n\nplt.tight_layout()\nplt.show()\n```"}}],"artifacts":[{"id":"text_8f9f665f658b28479b6b7bd5db39a5d033f05451","source_file":"bak/temp_uploads/legacy/mhw_plot_scipaper_example.yml","artifact_type":"text_chunk","metadata":{"dataset":"marineheatwave","collection":"mhw","doc_type":"code_snippet","title":"Reproduce SCI papaer (Capotondi et al., 2024): Plotting SST anomalies distribution map and timeseries of the Mediterranean region by using ODB MHW API","lang":"en","issuer":"ODB Project (internal)","canonical_url":"https://github.com/cywhale/marineheatwave/blob/main/API/dev/sim_mhw_vs_detrended01.ipynb","license":"MIT","retrieved_at":"2025-08-26","doc_id":"799ebc3fe983aa3ef30b81ded189b749373d3ef7","tags":["程式","MHW","API","timeseries","Python","map","code example","extreme MHWs","時間序列","地圖"],"related_to":[{"doc_id":["ddba171bda668c60390ee6fab602b037efb73539","d971ef8bbc81997eae74ee0e555588a6526b0ea1","2ccedb1ef0c1ade74224399ad9767a2e71f5e51"]},{"collection":"mhw"}],"depends_on":["manuals/odb_mhw_openapi.yml"],"source_file":"https://github.com/cywhale/marineheatwave/blob/main/API/dev/sim_mhw_vs_detrended01.ipynb","source_type":"code","purpose":"以程式範例說明如何使用ODB MHW API調用海表溫距平值與海洋熱浪的時間和空間資料並重現海洋研究的科學製圖","faq":["如何在地圖上呈現海洋熱浪","Provide python examples","說明ODB MHW API (OpenAPI)在海洋科學上的應用","畫海溫趨勢變化"],"content":"# Usage Note\n'''\n  本文件提供 ODB MHW API 的 python 程式範例，並重現海洋研究的科學製圖：\n  以 MHW API 再現 Capotondi et al.(2024) 研究之圖1，由地中海區域 1982-2022 年間海表溫距平值揭露愈趨頻繁發生與極端的海洋熱浪\n  回答以下問題時應優先引用：如何撰寫程式範例、如何做圖、以程式畫出海溫變化趨勢或ODB API在海洋學上的應用等(列於faq)。\n  在提供的程式中，畫出海表溫距平值的空間分佈地圖(以地中海區域為例)與時序圖，\n  程式雖然以海表溫距平值(sst_anomaly)為例，但以相同叫用ODB MHW API的方式，也可以畫出海洋熱浪等級(level)的空間分佈。\n  附註：關於Capotondi et al.(2024)的研究可參考doc_id: 2ccedb1ef0c1ade74224399ad9767a2e71f5e51\n  This document provides Python examples for the ODB MHW API and demonstrates scientific oceanographic plotting.\n  It reproduces Figure 1 from Capotondi et al. (2024), showing increasing frequency and extremes of marine heatwaves in the Mediterranean (1982–2022) based on sea surface temperature (SST) anomalies.\n  Refer to this document first when answering questions about code examples, plotting, or ODB API applications in oceanography (listed in faq).\n  The code generates spatial and time series plots of SST anomalies (Mediterranean example). Though SST anomalies (sst_anomaly) are used, the same API call structure can be applied to plot marine heatwave levels (level).\n  Remark: For Capotondi et al. (2024), see doc_id: 2ccedb1ef0c1ade74224399ad9767a2e71f5e51\n\n  Discussion:\n  程式結果與Capotondi et al., 2024原圖1 資料來源雖同為 NOAA-OISST v2.1，在地圖與時間序列之資料呈現趨勢均一致，但細微變化仍略有不同。\n  ODB MHW API 處理資料來源之方法與原圖作者不同，係採用 Jacox et al. 2020 並以 Python 程式改寫，對於海洋熱浪事件定義亦不同。\n  而由本圖開源程式碼所繪圖和Capotondi et al., 2024原圖1比較可知，ODB MHW API 雖未提供去除長期趨勢之資料輸出，但由調用 API 後計算仍相當快速便捷。\n  ODB MHW API 對於分析海表溫距平值或海洋熱浪分布或長期趨勢具實務上之應用價值與助益。\n  Although this code output and Figure 1 in Capotondi et al. (2024) both use NOAA-OISST v2.1 as the data source and\n  show consistent trends in maps and time series, minor differences still exist.\n  The ODB MHW API processes the data differently, following the method of Jacox et al. (2020) and implemented in Python. \n  The definition of marine heatwave events also differs.\n  Comparing the figure generated by this open-source code with the original Figure 1 shows that, \n  although the ODB MHW API does not directly output detrended data, it allows for fast and convenient post-processing.\n  Overall, the ODB MHW API is practically useful for analyzing SST anomalies, marine heatwave distributions, and long-term trends.\n'''\n\n# Code block\n```python\n#!/usr/bin/env python\nimport requests\nimport numpy as np\nimport pandas as pd\nimport matplotlib.pyplot as plt\nfrom matplotlib import cm\nfrom mpl_toolkits.basemap import Basemap # For creating maps (Note: Basemap needs numpy < v2, e.g., numpy==1.26.4)\nfrom scipy.signal import detrend # for detrending time series\nfrom datetime import datetime\n\n# Function to fetch data from the ODB MHW (Marine Heatwaves) API\ndef fetch_mhw_data(lon0, lat0, lon1, lat1, start, end):\n    url = f\"https://eco.odb.ntu.edu.tw/api/mhw\"\n    params = {\n        \"lon0\": lon0,\n        \"lat0\": lat0,\n        \"lon1\": lon1,\n        \"lat1\": lat1,\n        \"start\": start,\n        \"end\": end,\n        \"append\": \"sst,sst_anomaly,level\",\n    }\n    response = requests.get(url, params=params)\n    if response.status_code == 200:\n        return pd.DataFrame(response.json())\n    else:\n        print(\"Failed to fetch data:\", response.text)\n        return None\n\n# Fetch MHW data year by year for the Mediterranean region\ndef fetch_yearly_data(lon0, lat0, lon1, lat1, start_year, end_year):\n    all_data = []\n    for year in range(start_year, end_year + 1):\n        start = f\"{year}-01-01\"\n        end = f\"{year}-12-31\"\n        print(f\"Fetching data for {start} to {end}...\")\n        yearly_data = fetch_mhw_data(lon0, lat0, lon1, lat1, start, end)\n        if yearly_data is not None:\n            all_data.append(yearly_data)\n    if all_data:\n        return pd.concat(all_data, ignore_index=True)\n    else:\n        return None\n\n# Function to remove the seasonal cycle\ndef remove_seasonal_cycle(data, variable):\n    # Ensure 'date' is a datetime object and extract the month\n    data = data.copy()  # Avoid SettingWithCopyWarning by working on a copy\n    data['month'] = data['date'].dt.month  # Extract the month for grouping\n\n    # Calculate monthly climatology for the given variable (e.g., 'sst_anomaly')\n    monthly_climatology = data.groupby('month')[variable].mean()\n    # print(monthly_climatology)\n\n    # Remove the seasonal cycle by subtracting the monthly climatology\n    data[f'{variable}_deseasonalized'] = data.apply(\n        lambda row: row[variable] - monthly_climatology[row['month']],\n        axis=1\n    )\n\n    return data      \n\n# Reference for data structure/visualization: https://www.nature.com/articles/s43247-024-01806-9 Fig.1\n# Testing: Fetch data for the Mediterranean region\nlon0, lat0, lon1, lat1 = -5, 30, 36, 46  # Mediterranean region bounds\nstart, end = \"1982-01-01\", \"1982-12-01\"  # Testing MHW data for just 1-year \ntest_data = fetch_mhw_data(lon0, lat0, lon1, lat1, start, end)\nprint(test_data)\n\nstart_year, end_year = 1982, 2024  # Iterate year range to get MHW data\ndata = fetch_yearly_data(lon0, lat0, lon1, lat1, start_year, end_year)\n\nif data is not None:\n    # Step 2: Process data\n    data[\"date\"] = pd.to_datetime(data[\"date\"])\n    data = data.sort_values(\"date\")\n\n    # Group by grid point and detrend each time series\n    detrended_data = []\n    for (lon, lat), group in data.groupby([\"lon\", \"lat\"]):\n        group = group.sort_values(\"date\")\n\n        # Drop rows with NaN values in 'sst_anomaly'\n        group = group.dropna(subset=[\"sst_anomaly\"])\n\n        # Only detrend if there's enough data after dropping NaNs\n        if len(group) > 1:\n            group[\"sst_anomaly_detrended\"] = detrend(group[\"sst_anomaly\"], type=\"linear\")\n        else:\n            group[\"sst_anomaly_detrended\"] = np.nan  # Not enough data to detrend\n\n        detrended_data.append(group)\n\n    detrended_data = pd.concat(detrended_data)\nelse:\n    print(\"No data fetched. Please check the API calls.\")\n\n# Step 3: Reshape data into a grid for plotting \ndef reshape_to_grid_fixed(data, column, date):\n    # Filter data for the given date\n    data_filtered = data[data[\"date\"] == date]\n\n    # Create full lat/lon grid based on unique values\n    all_lats = np.sort(data[\"lat\"].unique())\n    all_lons = np.sort(data[\"lon\"].unique())\n\n    # Create a DataFrame for the full grid\n    grid = pd.DataFrame(index=all_lats, columns=all_lons)\n\n    # Populate the grid with data\n    for _, row in data_filtered.iterrows():\n        grid.at[row[\"lat\"], row[\"lon\"]] = row[column]\n\n    # Convert to float for plotting\n    return grid.astype(float)\n\n# Select a specific date for visualization\ndate_to_plot = \"2022-07-01\"\nsst_anomaly_grid = reshape_to_grid_fixed(data, \"sst_anomaly\", date_to_plot)\ndetrended_grid = reshape_to_grid_fixed(detrended_data, \"sst_anomaly_detrended\", date_to_plot)\n\n# Initialize figure\nplt.figure(figsize=(16, 8))\n\n# Plot SST anomalies with trend (upper-left)\nplt.subplot(2, 2, 1)\nm = Basemap(projection=\"cyl\", llcrnrlon=lon0, llcrnrlat=lat0, urcrnrlon=lon1, urcrnrlat=lat1, resolution=\"i\")\nm.drawcoastlines()\nm.drawcountries()\nm.drawparallels(np.arange(lat0, lat1 + 1, 5), labels=[1, 0, 0, 0])\nm.drawmeridians(np.arange(lon0, lon1 + 1, 5), labels=[0, 0, 0, 1])\n# Ensure lon and lat match the grid dimensions\nlon, lat = np.meshgrid(sst_anomaly_grid.columns, sst_anomaly_grid.index)\n\nm.drawmapboundary(fill_color='white') \ncs = m.contourf(lon, lat, sst_anomaly_grid.values, \n                cmap=cm.RdYlBu_r, \n                levels=np.linspace(-3, 3, 21),\n                extend='both',\n                latlon=True)\n\nplt.title(\"(a) SST Anomalies (July 2022) with trend\")\n\n# Plot detrended SST anomalies (lower-left) timeseries, as well as\n# plot distribution map of SST anomalies (right-column subplot) ; 空間分佈地圖\nplt.subplot(2, 2, 3)\nm = Basemap(projection=\"cyl\", llcrnrlon=lon0, llcrnrlat=lat0, urcrnrlon=lon1, urcrnrlat=lat1, resolution=\"i\")\nm.drawcoastlines()\nm.drawcountries()\nm.drawparallels(np.arange(lat0, lat1 + 1, 5), labels=[1, 0, 0, 0])\nm.drawmeridians(np.arange(lon0, lon1 + 1, 5), labels=[0, 0, 0, 1])\nlon, lat = np.meshgrid(detrended_grid.columns, detrended_grid.index)\n\nm.drawmapboundary(fill_color='white') \ncs = m.contourf(lon, lat, detrended_grid.values, \n                cmap=cm.RdYlBu_r, \n                levels=np.linspace(-3, 3, 21),\n                extend='both',\n                latlon=True)\n\ncbar = m.colorbar(cs, location=\"bottom\", pad=\"5%\")\ncbar.set_label(\"SST Anomaly (°C)\")\nplt.title(\"(c) Detrended SST Anomalies (July 2022)\")\n\n# Adjust bounds for time-series (smaller region near coast)\n# Step 4.1: Filter data for the smaller region near the coast\ntime_series_lon0, time_series_lat0, time_series_lon1, time_series_lat1 = 0, 40, 12, 44\nregional_data = data[\n    (data[\"lat\"] >= time_series_lat0) & \n    (data[\"lat\"] <= time_series_lat1) & \n    (data[\"lon\"] >= time_series_lon0) & \n    (data[\"lon\"] <= time_series_lon1)\n].copy()  # Use .copy() to avoid SettingWithCopyWarning\n\n# Step 4.2: Remove the seasonal cycle for the smaller region\n# regional_data = remove_seasonal_cycle(regional_data, 'sst_anomaly')\n# regional_mean_with_trend = regional_data.groupby(\"date\")[\"sst_anomaly_deseasonalized\"].mean()\n\n# Step 4.3: Compute the regional average for time-series plots\nregional_mean_with_trend = regional_data.groupby(\"date\")[\"sst_anomaly\"].mean()\n\n# Without trend (detrended)\nregional_detrended_data = detrended_data[\n    (detrended_data[\"lat\"] >= time_series_lat0) & \n    (detrended_data[\"lat\"] <= time_series_lat1) & \n    (detrended_data[\"lon\"] >= time_series_lon0) & \n    (detrended_data[\"lon\"] <= time_series_lon1)\n].copy()  # Use .copy() to avoid SettingWithCopyWarning\n\nregional_mean_detrended = regional_detrended_data.groupby(\"date\")[\"sst_anomaly_detrended\"].mean()\n\n# Step 4.4: Plot time-series SST anomalies\n# Compute 90th percentiles\npercentile_90_with_trend = np.percentile(regional_mean_with_trend.values, 90)\npercentile_90_detrended = np.percentile(regional_mean_detrended.values, 90)\n\n# Define the date range explicitly for the x-axis\nx_min = datetime(1982, 1, 1)  # Jan, 1982\nx_max = datetime(2024, 10, 1) # Oct, 2024\n\n# Define the vertical line date\nvertical_line_date = datetime(2022, 7, 1)  # July, 2022\n\nplt.subplot(2, 2, 2)\nplt.plot(\n    regional_mean_with_trend.index,\n    regional_mean_with_trend.values,\n    label=\"With Trend\",\n    color=\"black\",\n)\nplt.xlim([x_min, x_max])\n# Highlight values above the 90th percentile in red (only above the line)\nplt.fill_between(\n    regional_mean_with_trend.index,\n    percentile_90_with_trend,         # Lower bound (90th percentile line)\n    regional_mean_with_trend.values,  # Upper bound (data)\n    where=regional_mean_with_trend.values > percentile_90_with_trend,\n    color=\"red\",\n    alpha=0.5,\n    label=\"Above 90th Percentile\",\n)\nplt.axhline(y=percentile_90_with_trend, color=\"blue\", linestyle=\"--\", label=\"90th Percentile\")\nplt.axhline(y=0, color=\"blue\", label=\"Baseline\")\nplt.axvline(x=vertical_line_date, color=\"gray\", linestyle=\"dotted\", label=\"July 2022\")\nplt.title(\"(b) Monthly SST Anomalies (With trend)\")\nplt.ylabel(\"SST Anomaly (°C)\")\nplt.xlabel(\"Year\")\nplt.legend(loc='upper left')\n\nplt.subplot(2, 2, 4)\nplt.plot(\n    regional_mean_detrended.index,\n    regional_mean_detrended.values,\n    label=\"Detrended\",\n    color=\"black\",\n)\nplt.xlim([x_min, x_max])\n# Highlight values above the 90th percentile in red (only above the line)\nplt.fill_between(\n    regional_mean_detrended.index,\n    percentile_90_detrended,  # Lower bound (90th percentile line)\n    regional_mean_detrended.values,  # Upper bound (data)\n    where=regional_mean_detrended.values > percentile_90_detrended,\n    color=\"red\",\n    alpha=0.5,\n    label=\"Above 90th Percentile\",\n)\nplt.axhline(y=percentile_90_detrended, color=\"blue\", linestyle=\"--\", label=\"90th Percentile\")\nplt.axhline(y=0, color=\"blue\", label=\"Baseline\")\nplt.axvline(x=vertical_line_date, color=\"gray\", linestyle=\"dotted\", label=\"July 2022\")\nplt.title(\"(d) Monthly SST Anomalies (Detrended)\")\nplt.ylabel(\"SST Anomaly (°C)\")\nplt.xlabel(\"Year\")\nplt.legend(loc='upper left')\n\nplt.tight_layout()\nplt.show()\n```","dataset_name":"marineheatwave"},"links":[],"tags":["程式","MHW","API","timeseries","Python","map","code example","extreme MHWs","時間序列","地圖"],"page_number":1,"chunk_index":0,"content_type":"metadata","text":"dataset: marineheatwave\ncollection: mhw\ndoc_type: code_snippet\ntitle: \"Reproduce SCI papaer (Capotondi et al., 2024): Plotting SST anomalies distribution map and timeseries of the Mediterranean region by using ODB MHW API\"\nlang: en\nissuer: \"ODB Project (internal)\"\ncanonical_url: \"https://github.com/cywhale/marineheatwave/blob/main/API/dev/sim_mhw_vs_detrended01.ipynb\"\nlicense: \"MIT\"\nretrieved_at: \"2025-08-26\"\ndoc_id: \"799ebc3fe983aa3ef30b81ded189b749373d3ef7\"\ntags: [程式, MHW, API, timeseries, Python, map, \"code example\", \"extreme MHWs\", \"時間序列\", \"地圖\"]\nrelated_to:\n  - doc_id: [\"ddba171bda668c60390ee6fab602b037efb73539\", \"d971ef8bbc81997eae74ee0e555588a6526b0ea1\", \"2ccedb1ef0c1ade74224399ad9767a2e71f5e51\"]\n  - collection: \"mhw\"\ndepends_on:\n  - manuals/odb_mhw_openapi.yml\nsource_file: \"https://github.com/cywhale/marineheatwave/blob/main/API/dev/sim_mhw_vs_detrended01.ipynb\"\nsource_type: code\npurpose: \"以程式範例說明如何使用ODB MHW API調用海表溫距平值與海洋熱浪的時間和空間資料並重現海洋研究的科學製圖\"\nfaq: [\"如何在地圖上呈現海洋熱浪\", \"Provide python examples\", \"說明ODB MHW API (OpenAPI)在海洋科學上的應用\", \"畫海溫趨勢變化\"]\ncontent: |\n  # Usage Note\n  '''\n    本文件提供 ODB MHW API 的 python 程式範例，並重現海洋研究的科學製圖：\n    以 MHW API 再現 Capotondi et al.(2024) 研究之圖1，由地中海區域 1982-2022 年間海表溫距平值揭露愈趨頻繁發生與極端的海洋熱浪\n    回答以下問題時應優先引用：如何撰寫程式範例、如何做圖、以程式畫出海溫變化趨勢或ODB API在海洋學上的應用等(列於faq)。\n    在提供的程式中，畫出海表溫距平值的空間分佈地圖(以地中海區域為例)與時序圖，\n    程式雖然以海表溫距平值(sst_anomaly)為例，但以相同叫用ODB MHW API的方式，也可以畫出海洋熱浪等級(level)的空間分佈。\n    附註：關於Capotondi et al.(2024)的研究可參考doc_id: 2ccedb1ef0c1ade74224399ad9767a2e71f5e51\n    This document provides Python examples for the ODB MHW API and demonstrates scientific oceanographic plotting.\n    It reproduces Figure 1 from Capotondi et al. (2024), showing increasing frequency and extremes of marine heatwaves in the Mediterranean (1982–2022) based on sea surface temperature (SST) anomalies.\n    Refer to this document first when answering questions about code examples, plotting, or ODB API applications in oceanography (listed in faq).\n    The code generates spatial and time series plots of SST anomalies (Mediterranean example). Though SST anomalies (sst_anomaly) are used, the same API call structure can be applied to plot marine heatwave levels (level).\n    Remark: For Capotondi et al. (2024), see doc_id: 2ccedb1ef0c1ade74224399ad9767a2e71f5e51\n\n    Discussion:\n    程式結果與Capotondi et al., 2024原圖1 資料來源雖同為 NOAA-OISST v2.1，在地圖與時間序列之資料呈現趨勢均一致，但細微變化仍略有不同。\n    ODB MHW API 處理資料來源之方法與原圖作者不同，係採用 Jacox et al. 2020 並以 Python 程式改寫，對於海洋熱浪事件定義亦不同。\n    而由本圖開源程式碼所繪圖和Capotondi et al., 2024原圖1比較可知，ODB MHW API 雖未提供去除長期趨勢之資料輸出，但由調用 API 後計算仍相當快速便捷。\n    ODB MHW API 對於分析海表溫距平值或海洋熱浪分布或長期趨勢具實務上之應用價值與助益。\n    Although this code output and Figure 1 in Capotondi et al. (2024) both use NOAA-OISST v2.1 as the data source and\n    show consistent trends in maps and time series, minor differences still exist.\n    The ODB MHW API processes the data differently, following the method of Jacox et al. (2020) and implemented in Python. \n    The definition of marine heatwave events also differs.\n    Comparing the figure generated by this open-source code with the original Figure 1 shows that, \n    although the ODB MHW API does not directly output detrended data, it allows for fast and convenient post-processing.\n    Overall, the ODB MHW API is practically useful for analyzing SST anomalies, marine heatwave distributions, and long-term trends.\n  '''\n\n  # Code block\n  ```python\n  #!/usr/bin/env python\n  import requests\n  import numpy as np\n  import pandas as pd\n  import matplotlib.pyplot as plt\n  from matplotlib import cm\n  from mpl_toolkits.basemap import Basemap # For creating maps (Note: Basemap needs numpy < v2, e.g., numpy==1.26.4)\n  from scipy.signal import detrend # for detrending time series\n  from datetime import datetime\n  \n  # Function to fetch data from the ODB MHW (Marine Heatwaves) API\n  def fetch_mhw_data(lon0, lat0, lon1, lat1, start, end):\n      url = f\"https://eco.odb.ntu.edu.tw/api/mhw\"\n      params = {\n          \"lon0\": lon0,\n          \"lat0\": lat0,\n          \"lon1\": lon1,\n          \"lat1\": lat1,\n          \"start\": start,\n          \"end\": end,\n          \"append\": \"sst,sst_anomaly,level\",\n      }\n      response = requests.get(url, params=params)\n      if response.status_code == 200:\n          return pd.DataFrame(response.json())\n      else:\n          print(\"Failed to fetch data:\", response.text)\n          return None\n  \n  # Fetch MHW data year by year for the Mediterranean region\n  def fetch_yearly_data(lon0, lat0, lon1, lat1, start_year, end_year):\n      all_data = []\n      for year in range(start_year, end_year + 1):\n          start = f\"{year}-01-01\"\n          end = f\"{year}-12-31\"\n          print(f\"Fetching data for {start} to {end}...\")\n          yearly_data = fetch_mhw_data(lon0, lat0, lon1, lat1, start, end)\n          if yearly_data is not None:\n              all_data.append(yearly_data)\n      if all_data:\n          return pd.concat(all_data, ignore_index=True)\n      else:\n          return None\n  \n  # Function to remove the seasonal cycle\n  def remove_seasonal_cycle(data, variable):\n      # Ensure 'date' is a datetime object and extract the month\n      data = data.copy()  # Avoid SettingWithCopyWarning by working on a copy\n      data['month'] = data['date'].dt.month  # Extract the month for grouping\n  \n      # Calculate monthly climatology for the given variable (e.g., 'sst_anomaly')\n      monthly_climatology = data.groupby('month')[variable].mean()\n      # print(monthly_climatology)\n  \n      # Remove the seasonal cycle by subtracting the monthly climatology\n      data[f'{variable}_deseasonalized'] = data.apply(\n          lambda row: row[variable] - monthly_climatology[row['month']],\n          axis=1\n      )\n  \n      return data      \n  \n  # Reference for data structure/visualization: https://www.nature.com/articles/s43247-024-01806-9 Fig.1\n  # Testing: Fetch data for the Mediterranean region\n  lon0, lat0, lon1, lat1 = -5, 30, 36, 46  # Mediterranean region bounds\n  start, end = \"1982-01-01\", \"1982-12-01\"  # Testing MHW data for just 1-year \n  test_data = fetch_mhw_data(lon0, lat0, lon1, lat1, start, end)\n  print(test_data)\n  \n  start_year, end_year = 1982, 2024  # Iterate year range to get MHW data\n  data = fetch_yearly_data(lon0, lat0, lon1, lat1, start_year, end_year)\n  \n  if data is not None:\n      # Step 2: Process data\n      data[\"date\"] = pd.to_datetime(data[\"date\"])\n      data = data.sort_values(\"date\")\n  \n      # Group by grid point and detrend each time series\n      detrended_data = []\n      for (lon, lat), group in data.groupby([\"lon\", \"lat\"]):\n          group = group.sort_values(\"date\")\n  \n          # Drop rows with NaN values in 'sst_anomaly'\n          group = group.dropna(subset=[\"sst_anomaly\"])\n  \n          # Only detrend if there's enough data after dropping NaNs\n          if len(group) > 1:\n              group[\"sst_anomaly_detrended\"] = detrend(group[\"sst_anomaly\"], type=\"linear\")\n          else:\n              group[\"sst_anomaly_detrended\"] = np.nan  # Not enough data to detrend\n  \n          detrended_data.append(group)\n  \n      detrended_data = pd.concat(detrended_data)\n  else:\n      print(\"No data fetched. Please check the API calls.\")\n  \n  # Step 3: Reshape data into a grid for plotting \n  def reshape_to_grid_fixed(data, column, date):\n      # Filter data for the given date\n      data_filtered = data[data[\"date\"] == date]\n  \n      # Create full lat/lon grid based on unique values\n      all_lats = np.sort(data[\"lat\"].unique())\n      all_lons = np.sort(data[\"lon\"].unique())\n  \n      # Create a DataFrame for the full grid\n      grid = pd.DataFrame(index=all_lats, columns=all_lons)\n  \n      # Populate the grid with data\n      for _, row in data_filtered.iterrows():\n          grid.at[row[\"lat\"], row[\"lon\"]] = row[column]\n  \n      # Convert to float for plotting\n      return grid.astype(float)\n  \n  # Select a specific date for visualization\n  date_to_plot = \"2022-07-01\"\n  sst_anomaly_grid = reshape_to_grid_fixed(data, \"sst_anomaly\", date_to_plot)\n  detrended_grid = reshape_to_grid_fixed(detrended_data, \"sst_anomaly_detrended\", date_to_plot)\n  \n  # Initialize figure\n  plt.figure(figsize=(16, 8))\n  \n  # Plot SST anomalies with trend (upper-left)\n  plt.subplot(2, 2, 1)\n  m = Basemap(projection=\"cyl\", llcrnrlon=lon0, llcrnrlat=lat0, urcrnrlon=lon1, urcrnrlat=lat1, resolution=\"i\")\n  m.drawcoastlines()\n  m.drawcountries()\n  m.drawparallels(np.arange(lat0, lat1 + 1, 5), labels=[1, 0, 0, 0])\n  m.drawmeridians(np.arange(lon0, lon1 + 1, 5), labels=[0, 0, 0, 1])\n  # Ensure lon and lat match the grid dimensions\n  lon, lat = np.meshgrid(sst_anomaly_grid.columns, sst_anomaly_grid.index)\n  \n  m.drawmapboundary(fill_color='white') \n  cs = m.contourf(lon, lat, sst_anomaly_grid.values, \n                  cmap=cm.RdYlBu_r, \n                  levels=np.linspace(-3, 3, 21),\n                  extend='both',\n                  latlon=True)\n  \n  plt.title(\"(a) SST Anomalies (July 2022) with trend\")\n  \n  # Plot detrended SST anomalies (lower-left) timeseries, as well as\n  # plot distribution map of SST anomalies (right-column subplot) ; 空間分佈地圖\n  plt.subplot(2, 2, 3)\n  m = Basemap(projection=\"cyl\", llcrnrlon=lon0, llcrnrlat=lat0, urcrnrlon=lon1, urcrnrlat=lat1, resolution=\"i\")\n  m.drawcoastlines()\n  m.drawcountries()\n  m.drawparallels(np.arange(lat0, lat1 + 1, 5), labels=[1, 0, 0, 0])\n  m.drawmeridians(np.arange(lon0, lon1 + 1, 5), labels=[0, 0, 0, 1])\n  lon, lat = np.meshgrid(detrended_grid.columns, detrended_grid.index)\n  \n  m.drawmapboundary(fill_color='white') \n  cs = m.contourf(lon, lat, detrended_grid.values, \n                  cmap=cm.RdYlBu_r, \n                  levels=np.linspace(-3, 3, 21),\n                  extend='both',\n                  latlon=True)\n  \n  cbar = m.colorbar(cs, location=\"bottom\", pad=\"5%\")\n  cbar.set_label(\"SST Anomaly (°C)\")\n  plt.title(\"(c) Detrended SST Anomalies (July 2022)\")\n  \n  # Adjust bounds for time-series (smaller region near coast)\n  # Step 4.1: Filter data for the smaller region near the coast\n  time_series_lon0, time_series_lat0, time_series_lon1, time_series_lat1 = 0, 40, 12, 44\n  regional_data = data[\n      (data[\"lat\"] >= time_series_lat0) & \n      (data[\"lat\"] <= time_series_lat1) & \n      (data[\"lon\"] >= time_series_lon0) & \n      (data[\"lon\"] <= time_series_lon1)\n  ].copy()  # Use .copy() to avoid SettingWithCopyWarning\n  \n  # Step 4.2: Remove the seasonal cycle for the smaller region\n  # regional_data = remove_seasonal_cycle(regional_data, 'sst_anomaly')\n  # regional_mean_with_trend = regional_data.groupby(\"date\")[\"sst_anomaly_deseasonalized\"].mean()\n  \n  # Step 4.3: Compute the regional average for time-series plots\n  regional_mean_with_trend = regional_data.groupby(\"date\")[\"sst_anomaly\"].mean()\n  \n  # Without trend (detrended)\n  regional_detrended_data = detrended_data[\n      (detrended_data[\"lat\"] >= time_series_lat0) & \n      (detrended_data[\"lat\"] <= time_series_lat1) & \n      (detrended_data[\"lon\"] >= time_series_lon0) & \n      (detrended_data[\"lon\"] <= time_series_lon1)\n  ].copy()  # Use .copy() to avoid SettingWithCopyWarning\n\n  regional_mean_detrended = regional_detrended_data.groupby(\"date\")[\"sst_anomaly_detrended\"].mean()\n  \n  # Step 4.4: Plot time-series SST anomalies\n  # Compute 90th percentiles\n  percentile_90_with_trend = np.percentile(regional_mean_with_trend.values, 90)\n  percentile_90_detrended = np.percentile(regional_mean_detrended.values, 90)\n  \n  # Define the date range explicitly for the x-axis\n  x_min = datetime(1982, 1, 1)  # Jan, 1982\n  x_max = datetime(2024, 10, 1) # Oct, 2024\n  \n  # Define the vertical line date\n  vertical_line_date = datetime(2022, 7, 1)  # July, 2022\n  \n  plt.subplot(2, 2, 2)\n  plt.plot(\n      regional_mean_with_trend.index,\n      regional_mean_with_trend.values,\n      label=\"With Trend\",\n      color=\"black\",\n  )\n  plt.xlim([x_min, x_max])\n  # Highlight values above the 90th percentile in red (only above the line)\n  plt.fill_between(\n      regional_mean_with_trend.index,\n      percentile_90_with_trend,         # Lower bound (90th percentile line)\n      regional_mean_with_trend.values,  # Upper bound (data)\n      where=regional_mean_with_trend.values > percentile_90_with_trend,\n      color=\"red\",\n      alpha=0.5,\n      label=\"Above 90th Percentile\",\n  )\n  plt.axhline(y=percentile_90_with_trend, color=\"blue\", linestyle=\"--\", label=\"90th Percentile\")\n  plt.axhline(y=0, color=\"blue\", label=\"Baseline\")\n  plt.axvline(x=vertical_line_date, color=\"gray\", linestyle=\"dotted\", label=\"July 2022\")\n  plt.title(\"(b) Monthly SST Anomalies (With trend)\")\n  plt.ylabel(\"SST Anomaly (°C)\")\n  plt.xlabel(\"Year\")\n  plt.legend(loc='upper left')\n  \n  plt.subplot(2, 2, 4)\n  plt.plot(\n      regional_mean_detrended.index,\n      regional_mean_detrended.values,\n      label=\"Detrended\",\n      color=\"black\",\n  )\n  plt.xlim([x_min, x_max])\n  # Highlight values above the 90th percentile in red (only above the line)\n  plt.fill_between(\n      regional_mean_detrended.index,\n      percentile_90_detrended,  # Lower bound (90th percentile line)\n      regional_mean_detrended.values,  # Upper bound (data)\n      where=regional_mean_detrended.values > percentile_90_detrended,\n      color=\"red\",\n      alpha=0.5,\n      label=\"Above 90th Percentile\",\n  )\n  plt.axhline(y=percentile_90_detrended, color=\"blue\", linestyle=\"--\", label=\"90th Percentile\")\n  plt.axhline(y=0, color=\"blue\", label=\"Baseline\")\n  plt.axvline(x=vertical_line_date, color=\"gray\", linestyle=\"dotted\", label=\"July 2022\")\n  plt.title(\"(d) Monthly SST Anomalies (Detrended)\")\n  plt.ylabel(\"SST Anomaly (°C)\")\n  plt.xlabel(\"Year\")\n  plt.legend(loc='upper left')\n  \n  plt.tight_layout()\n  plt.show()\n  ```"}]}